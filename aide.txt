
python -m pip install pyinstaller
python -m PyInstaller --noconfirm --windowed --onefile --name Provenderie --collect-data ttkbootstrap main.py








en voulan faire sortir un produit l

je veux savoir a une certaine periode les produit qui ont ete ajouter , leur prix total ainsi que 
les produits sortie et leux prix au total pur connaitre le benefice fait dans cette periode la

faire en sorte que lorsquon veut faire un out cest a dire une sortie de produit 
que la quantité entrer soit pas superieur au stock actuelle

je souhaite avoir une colone en surplus dans le tableau qui indique les mouvements ,
une colonne qui indique le total des stock pour le filtrage 
et le total egalement pour le prix en considerant le type (in , out ,  adj  ou tous) qui a ete selectionner lors du filtre.
si tu rencontre in fait addition , out fait soustration et adj ..

sur le dashbore je veux savoir combien de sac de produit jai

bien gerer larchivage et lunicité (SKU et libelle) lors de lenregistrement dun produit en tenant aussi compte de la casse


je ne suis pas parfait

surtout ne tentez pas le diable

des gens s'immagine que le pouvoir siege a la maison blanche, mais c'est faux. 
Les multi nationnales et les crimes organisés sont les vraies dirigeants de la planette.


c'est est un ou une.
Madame , cette conversation est terminée.

ne jamais suivre largumentation de son adversaire , soyez focus sur votre argumentation a 
vous de peur a etre troubler par celle de votre adversaire


je ne peut que vous dire la veriter , pas vous obliger a la croire.
compte off shore

j'assume completement ce que je suis

je ne vais pas vous supplier de m'accorder le privilege de vous aider




























































import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
from ttkbootstrap import DateEntry  # Import direct de DateEntry
from .base import BasePage
from .dialogs import MovementDialog
from utils import kg_to_bag_repr

class MovementsPage(BasePage):
    def on_show(self):
        self.build()
        self.refresh()

    def build(self):
        for w in self.winfo_children():
            w.destroy()

        header = ttk.Frame(self); header.pack(fill=X)
        ttk.Label(header, text="Mouvements (Entrées / Sorties / Ajustements)", font="-size 14 -weight bold").pack(side=LEFT)
        ttk.Button(header, text="Nouveau mouvement", bootstyle="success", command=self.new_movement).pack(side=RIGHT)

        ttk.Separator(self).pack(fill=X, pady=10)

        # Filters
        f = ttk.Frame(self); f.pack(fill=X)
        self.q_var = ttk.StringVar()
        self.type_var = ttk.StringVar(value="Tous")
        self.shop_var = ttk.StringVar(value="Toutes")
        
        shops = self.app.db.list_shops()
        shop_names = ["Toutes"] + [s["libelle"] for s in shops]
        ttk.Label(f, text="Recherche").pack(side=LEFT, padx=(0,6))
        ttk.Entry(f, textvariable=self.q_var, width=20).pack(side=LEFT)
        ttk.Label(f, text="Type").pack(side=LEFT, padx=(10,6))
        ttk.Combobox(f, values=["Tous","IN","OUT","ADJ"], textvariable=self.type_var, width=8, state="readonly").pack(side=LEFT)
        ttk.Label(f, text="Boutique").pack(side=LEFT, padx=(10,6))
        ttk.Combobox(f, values=shop_names, textvariable=self.shop_var, width=25, state="readonly").pack(side=LEFT)
        
        ttk.Label(f, text="Du").pack(side=LEFT, padx=(10,6))
        self.date_from_entry = DateEntry(f, width=12, dateformat="%Y-%m-%d", bootstyle="primary")
        self.date_from_entry.pack(side=LEFT)

        ttk.Label(f, text="Au").pack(side=LEFT, padx=(6,6))
        self.date_to_entry = DateEntry(f, width=12, dateformat="%Y-%m-%d", bootstyle="primary")
        self.date_to_entry.pack(side=LEFT)
        
        ttk.Button(f, text="Filtrer", bootstyle="secondary", command=self.refresh).pack(side=LEFT, padx=8)
        ttk.Button(f, text="Rafraîchir", bootstyle="info", command=self.refresh).pack(side=LEFT)

        # ---
        # Summary Frame
        # ---
        summary_frame = ttk.Frame(self)
        summary_frame.pack(fill=X, pady=(10, 0))

        # Labels to display summary values
        self.total_in_var = ttk.StringVar(value="Valeur des entrées : 0.00 FCFA")
        self.total_out_var = ttk.StringVar(value="Valeur des sorties : 0.00 FCFA")
        self.profit_var = ttk.StringVar(value="Bénéfice net : 0.00 FCFA")

        ttk.Label(summary_frame, textvariable=self.total_in_var, font="-size 10 -weight bold", bootstyle="success").pack(side=LEFT, padx=(0, 20))
        ttk.Label(summary_frame, textvariable=self.total_out_var, font="-size 10 -weight bold", bootstyle="danger").pack(side=LEFT, padx=(0, 20))
        self.profit_label = ttk.Label(summary_frame, textvariable=self.profit_var, font="-size 12 -weight bold")
        self.profit_label.pack(side=LEFT)

        ttk.Separator(self).pack(fill=X, pady=10)

        # Table
        cols = ("date","type","produit","boutique","quantite","en_sacs","prix_unit","note")
        self.tree = ttk.Treeview(self, columns=cols, show="headings", height=22, bootstyle="info")
        self.tree.pack(fill=BOTH, expand=YES, pady=10)

        headers = {
            "date":"Date", "type":"Type", "produit":"Produit", "boutique":"Boutique",
            "quantite":"Qté (kg)", "en_sacs":"Qté (sacs+kg)", "prix_unit":"Prix/kg", "note":"Note"
        }
        for c in cols:
            self.tree.heading(c, text=headers[c])
            anchor = E if c in ("quantite","prix_unit") else W
            self.tree.column(c, width=120 if c not in ("note","produit") else 220, anchor=anchor)

    def refresh(self):
        for i in self.tree.get_children():
            self.tree.delete(i)

        mtype = self.type_var.get()
        mt = None if mtype == "Tous" else mtype

        shop_name = self.shop_var.get()
        shops = self.app.db.list_shops()
        shop_id = None
        if shop_name and shop_name != "Toutes":
            for s in shops:
                if s["libelle"] == shop_name:
                    shop_id = s["id"]
                    break

        date_from = self.date_from_entry.entry.get().strip() or None
        date_to = self.date_to_entry.entry.get().strip() or None

        items = self.app.db.list_movements(
            mtype=mt,
            shop_id=shop_id,
            q=self.q_var.get(),
            date_from=date_from,
            date_to=date_to
        )

        total_in_value = 0
        total_out_value = 0
        
        # ---
        # Logique de calcul du bénéfice mise à jour
        # ---
        for m in items:
            # Pour que ce calcul soit précis, la méthode `list_movements` de votre base de données
            # doit retourner `prix_sac` en plus des informations existantes.
            # On suppose ici que votre base de données a été mise à jour pour inclure cette information.
            
            # Récupération des prix et des quantités
            price_kg = m.get("unit_price_kg", 0)
            prix_sac = m.get("prix_sac", 0)
            
            # IMPORTANT: La base de données ne stocke que la quantité totale en kg.
            # Pour retrouver la répartition entre sacs et kilos, il faut faire une division
            # ce qui peut être imprécis.
            # L'idéal serait de stocker `qty_sac` et `qty_kg_saisie` dans la base de données.
            
            # Utilisation de la quantité totale en kg pour un calcul simplifié et cohérent.
            # Ceci ne prend pas en compte le prix par sac si la quantité initiale n'a pas été
            # saisie comme "x sacs et y kilos".
            
            if m["type"] == "IN":
                # Pour les entrées, on utilise le prix unitaire par kg
                total_in_value += m["qty_kg"] * price_kg
            elif m["type"] == "OUT":
                # Pour les sorties, on utilise le prix de vente total
                # Pour le calcul du bénéfice, on a besoin du coût d'achat.
                # Votre base de données ne stocke pas le prix d'achat, on va donc
                # utiliser un calcul simplifié pour les valeurs.
                
                # Le calcul du bénéfice est : prix de vente - prix d'achat.
                # L'exemple que vous avez donné était : (3 sacs * prix_sac) + (4 kg * prix_kg)
                # On va donc faire ce calcul en supposant que la BD contient les bonnes infos
                
                # IMPORTANT: Cette ligne suppose que la BD a des champs pour `qty_sac_saisie`
                # et `qty_kg_saisie`, qui ne sont pas dans votre code initial.
                # Pour un calcul précis, vous devriez modifier votre base de données.
                # En attendant, on utilise le calcul basé sur le prix par kg.
                total_out_value += abs(m["qty_kg"]) * price_kg

        # Calcul du bénéfice. Ce calcul est un simple exemple.
        # Le calcul de bénéfice réel est plus complexe et nécessite les coûts d'achat.
        profit = total_out_value - total_in_value
        
        self.total_in_var.set(f"Valeur des entrées : {total_in_value:,.2f} FCFA")
        self.total_out_var.set(f"Valeur des sorties : {total_out_value:,.2f} FCFA")
        self.profit_var.set(f"Bénéfice net : {profit:,.2f} FCFA")
        
        if profit >= 0:
            self.profit_label.config(bootstyle="success")
        else:
            self.profit_label.config(bootstyle="danger")

        for m in items:
            sacs_repr = kg_to_bag_repr(abs(m["qty_kg"]), m["poids_sac_kg"])
            self.tree.insert("", END, values=(
                m["created_at"], m["type"], m["product_libelle"], m["shop_libelle"],
                f'{m["qty_kg"]:.2f}', sacs_repr, f'{(m["unit_price_kg"] or 0):.0f}', m.get("note","")
            ))

    def new_movement(self):
        MovementDialog(self.app, on_saved=self.refresh)
